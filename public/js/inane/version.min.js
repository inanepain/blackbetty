const matches=['HIGHER','EQUAL','LOWER'];class VersionMatch{#name;#value;constructor({name,value}){if(VersionMatch[name])return VersionMatch[name];else if(!matches.includes(name))return VersionMatch.EQUAL;this.#name=name;this.#value=value;Object.defineProperties(this,{name:{enumerable:true,value:this.#name,},value:{enumerable:true,value:this.#value,},});}
static from(value){const t={'1':'HIGHER','0':'EQUAL','-1':'LOWER',};return this[t[value]]||null;}}
Object.defineProperties(VersionMatch,{HIGHER:{value:new VersionMatch({value:1,name:'HIGHER'}),enumerable:true,},EQUAL:{value:new VersionMatch({value:0,name:'EQUAL'}),enumerable:true,},LOWER:{value:new VersionMatch({value:-1,name:'LOWER'}),enumerable:true,},});class Version{#version;#lexicographical;#zeroExtend;constructor(version,{lexicographical,zeroExtend=true}={}){if(!version)throw new SyntaxError('Missing parameter: version');if(!version.split('.').every(this.#isValidPart))throw new SyntaxError('Invalid parameter `version` must be a semver version string');this.#version=version;this.#lexicographical=lexicographical;this.#zeroExtend=zeroExtend;}
get version(){return this.#version;}#isValidPart(part){return(this?.#lexicographical?/^\d+[A-Za-z]*$/:/^\d+$/).test(part);}
compare(version){let v1parts=version.split('.'),v2parts=this.#version.split('.');if(!v1parts.every(this.#isValidPart))return NaN;if(this.#zeroExtend){while(v1parts.length<v2parts.length)v1parts.push('0');while(v2parts.length<v1parts.length)v2parts.push('0');}
if(!this.#lexicographical){v1parts=v1parts.map(Number);v2parts=v2parts.map(Number);}
for(var i=0;i<v1parts.length;++i){if(v2parts.length==i)return VersionMatch.HIGHER;if(v1parts[i]==v2parts[i])continue;else if(v1parts[i]>v2parts[i])return VersionMatch.HIGHER;else return VersionMatch.LOWER;}
if(v1parts.length!=v2parts.length)return VersionMatch.LOWER;return VersionMatch.EQUAL;}
isHigher(version){return this.compare(version)==VersionMatch.HIGHER;}
isHigherOrEqual(version){return this.compare(version)?.value>=VersionMatch.EQUAL.value;}
isEqual(version){return this.compare(version)==VersionMatch.EQUAL;}
isLowerOrEqual(version){return this.compare(version)?.value<=VersionMatch.EQUAL.value;}
isLower(version){return this.compare(version)==VersionMatch.LOWER;}}
export{Version,VersionMatch};