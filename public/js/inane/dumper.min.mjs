const out=console;class LogLevel{#options;constructor({name,value}){this.#options=arguments[0];Object.defineProperties(this,{name:{enumerable:true,value:this.#options.name},value:{enumerable:true,value:this.#options.value}})}static from(level){if(level instanceof LogLevel&&Dumper[level.name])return Dumper[level.name];else if(typeof level==`string`&&Dumper[level.toUpperCase()])return Dumper[level.toUpperCase()];else if(Dumper[level])return Dumper[level];else if(Dumper[level?.value])return Dumper[level?.value];else if(Dumper[level?.name?.toUpperCase()])return Dumper[level?.name?.toUpperCase()];return defaults.level}allows(level){if([defaults.level,level].includes(Dumper.OFF))return false;if(level==undefined)return true;return this.value-level.value<=0}}const isStatic=obj=>obj===Dumper;const copyObject=original=>{return JSON.parse(JSON.stringify(original))};const mergeOptions=(target,...source)=>{var key,i;for(i=0;i<source.length;i++)for(key in source[i])if(!(key in target)&&source[i].hasOwnProperty(key))target[key]=source[i][key];else try{if(target[key].constructor===Object&&source[i][key].constructor===Object)mergeOptions(target[key],source[i][key])}catch(error){if(error.message.includes("target[key].constructor"))target[key]=source[i][key]}};const throttle=(func,limitDelay=1e3,options={})=>{mergeOptions(options,{skipfirst:false,context:func});let inThrottle=options.skipfirst;let inDebounce;return function(){const args=arguments;const context=options.context;if(!inThrottle){inThrottle=true;func.apply(context,args);inThrottle=setTimeout(()=>inThrottle=undefined,limitDelay)}else{clearTimeout(inDebounce);inDebounce=setTimeout(()=>func.apply(context,args),limitDelay)}}};const formatMessage=(messages,context,style=false)=>{if(typeof context!==`undefined`&&Array.isArray(context.name)&&context.name.length>0){const name="[".concat(context.name.join(" - ")).concat("]");if(style)messages.unshift(Object.entries(style).join("; ").replaceAll(",",": ").concat(";"));messages.unshift((style?"%c":"").concat(name))}};const funcs=["log","trace","debug","info","warn","error","time","timeEnd","timeLog","timeStamp","count","countReset","getLevel","setLevel","children","assert"];const Children=new Map;const Counters={default:0};const LogLevels=(()=>{const LogLevels=Object.create(null);Object.defineProperties(LogLevels,{TRACE:{value:new LogLevel({value:1,name:"TRACE"}),enumerable:true},DEBUG:{value:new LogLevel({value:2,name:"DEBUG"}),enumerable:true},INFO:{value:new LogLevel({value:3,name:"INFO"}),enumerable:true},TIME:{value:new LogLevel({value:4,name:"TIME"}),enumerable:true},WARN:{value:new LogLevel({value:5,name:"WARN"}),enumerable:true},ERROR:{value:new LogLevel({value:8,name:"ERROR"}),enumerable:true},OFF:{value:new LogLevel({value:99,name:"OFF"}),enumerable:true}});Object.freeze(LogLevels);return LogLevels})();class Dumper{static get VERSION(){return"2.5.0"}get VERSION(){return this.constructor.VERSION}#options;#children;static get kids(){return this.children()}get kids(){return this.children()}#context={name:[]};#counters={default:0};constructor({clear=false,level=Dumper.WARN,bubbling={listen:true,trigger:true},trickle=1e3,assert={time:false,hhmmss:false,limit:0}}=defaults){this.#options=this.#parseOptions(arguments[0]||defaults);if(!(this.#options.level instanceof LogLevel))this.#options.level=LogLevel.from(this.#options.level);for(const func of funcs)this[func]=Dumper[func].bind(this);this.group=out.group.bind(this);this.groupCollapsed=out.groupCollapsed.bind(this);this.groupEnd=out.groupEnd.bind(this);this.clear=out.clear.bind(this);this.trickle=throttle(this.debug,this.#options.trickle,{context:this});if(!this.dump)this.dump=()=>{};if(this.#options.clear)this.clear()}#parseOptions(options){const picked={};Object.keys(defaults).forEach(key=>{if(options.hasOwnProperty(key))picked[key]=options[key]});mergeOptions(picked,defaults);picked.id=Date.now();if(options.linked===true){this.get=Dumper.get.bind(this);this.#children=new Map;this.#context=options.context}else this.get=Dumper.get.bind(Dumper);return picked}static get(name,{clear=false,level=Dumper.WARN,bubbling={listen:true,trigger:true},trickle=1e3,assert={time:false,hhmmss:false,limit:0}}=defaults){let options=arguments[1]??{};const children=this==Dumper||this.#children==undefined?Children:this.#children;if(!children.has(name)){if(this!=Dumper)mergeOptions(options,this.#options);if(options.level&&options.level.name)options.level=options.level.name;options=copyObject(options);options.level=LogLevel.from(options.level);let context=this==Dumper?{name:[]}:copyObject(this.#context);context.parent=this;context.name.push(name);options.linked=true;options.context=context;const child=new Dumper(options);child.name=name;children.set(name,child)}return children.get(name)}static children(){const kids=Object.create(null);for(let[name,child]of this!=Dumper&&this.#children||Children)kids[name]=child;return kids}static get TRACE(){return LogLevels.TRACE}static get DEBUG(){return LogLevels.DEBUG}static get INFO(){return LogLevels.INFO}static get TIME(){return LogLevels.TIME}static get WARN(){return LogLevels.WARN}static get ERROR(){return LogLevels.ERROR}static get OFF(){return LogLevels.OFF}static get 1(){return this.TRACE}static get 2(){return this.DEBUG}static get 3(){return this.INFO}static get 4(){return this.TIME}static get 5(){return this.WARN}static get 8(){return this.ERROR}static get 99(){return this.OFF}static getLevel(){return(isStatic(this)?defaults:this.#options).level}static setLevel(level,bubbled=false){let options=this==Dumper||this.#options==undefined?defaults:this.#options;if(!(level instanceof LogLevel))level=LogLevel.from(level);if(!bubbled||(this==Dumper||options.bubbling.listen))options.level=level;if(this==Dumper&&level==this.OFF||bubbled&&options.bubbling.trigger==false)return;if(this!=Dumper&&this.#children==undefined)return this;if(options.bubbling.trigger)for(let child of(this!=Dumper&&this.#children||Children).values())child.setLevel(level,true);return this}static get level(){return this.getLevel()}static set level(level){return this.setLevel(level)}get level(){return this.getLevel()}set level(level){return this.setLevel(level)}static dump(...msgs){if(out.dump)return out.dump.apply(this,msgs)}static trace(...messages){formatMessage(messages,this==Dumper?undefined:this.#context,{color:"DarkBlue"});if(this.getLevel().allows(Dumper.TRACE))return out.trace.apply(this,messages)}static debug(...messages){formatMessage(messages,this==Dumper?undefined:this.#context,{color:"LightBlue"});if(this.getLevel().allows(Dumper.DEBUG))return out.debug.apply(this,messages)}static info(...messages){formatMessage(messages,this==Dumper?undefined:this.#context,{color:"Blue"});if(this.getLevel().allows(Dumper.INFO))return out.info.apply(this,messages)}static warn(...messages){formatMessage(messages,this==Dumper?undefined:this.#context,{color:"Orange"});if(this.getLevel().allows(Dumper.WARN))return out.warn.apply(this,messages)}static error(...messages){formatMessage(messages,this==Dumper?undefined:this.#context,{color:"DarkRed"});if(this.getLevel().allows(Dumper.ERROR))return out.error.apply(this,messages)}static log(...messages){formatMessage(messages,this==Dumper?undefined:this.#context,{color:"Black"});if(this.getLevel().allows())return out.log.apply(this,messages)}static assert(assertion,...messages){formatMessage(messages,this==Dumper?undefined:this.#context,{color:"Crimson"});const new_ts=Date.now();const old_ts=this._last_assert||0;const options=this==Dumper?defaults:this.#options;if(options.assert.limit&&old_ts&&new_ts-old_ts<options.assert.limit)return false;if(options.assert.time){messages.push(new_ts);const gap_ts=new_ts-old_ts;if(options.assert.hhmmss)messages.push(new Date(gap_ts).toISOString().substring(11,8).replace(new RegExp("^(00:)+","gm"),""));else messages.push(gap_ts)}this._last_assert=new_ts;messages.unshift(assertion);if(this.getLevel().allows()){out.assert.apply(this,messages);return!assertion}return false}static time(label="default"){let messages=[label];formatMessage(messages,this==Dumper?undefined:this.#context);if(this.getLevel().allows(Dumper.TIME))return out.time.call(this,messages.join(" - "))}static timeEnd(label="default"){let messages=[label];formatMessage(messages,this==Dumper?undefined:this.#context);if(this.getLevel().allows(Dumper.TIME))return out.timeEnd.call(this,messages.join(" - "))}static timeLog(label="default"){let messages=[label];formatMessage(messages,this==Dumper?undefined:this.#context);if(this.getLevel().allows(Dumper.TIME))return out.timeLog.call(this,messages.join(" - "))}static timeStamp(){let messages=[Date.now()];formatMessage(messages,this==Dumper?undefined:this.#context);if(this.getLevel().allows(Dumper.TIME))out.log.call(this,messages.join(" - "));out.timeStamp.call(this);return this}static count(label="default",returnCount=false){const counters=this==Dumper?Counters:this.#counters;if(!counters.hasOwnProperty(label))counters[label]=0;counters[label]+=1;let messages=[`${label}: `+counters[label]];formatMessage(messages,this==Dumper?undefined:this.#context);if(this.getLevel().allows(Dumper.TIME))out.log.call(this,messages.join(" - "));return returnCount?counters[label]:this}static countReset(label="default"){const counters=this==Dumper?Counters:this.#counters;if(counters.hasOwnProperty(label))counters[label]=0;return this}get optionAssertTime(){return this.#options.assert.time}set optionAssertTime(assertTime){this.#options.assert.time=Boolean(assertTime)}get optionAssertLimit(){return this.#options.assert.limit}set optionAssertLimit(assertLimit){assertLimit=assertLimit*1;this.#options.assert.limit=assertLimit.toString()=="NaN"?0:assertLimit}get optionBubbleFromParent(){return this.#options.bubbling.listen}set optionBubbleFromParent(bubble){this.#options.bubbling.listen=Boolean(bubble);return this}get optionBubbleToChildren(){return this.#options.bubbling.trigger}set optionBubbleToChildren(bubble){this.#options.bubbling.trigger=Boolean(bubble);return this}get optionBubble(){return this.optionBubbleFromParent==this.optionBubbleToChildren&&this.optionBubbleToChildren||null}set optionBubble(bubble){this.optionBubbleFromParent=bubble;this.optionBubbleToChildren=bubble;return this}}const defaults={clear:false,level:Dumper.WARN,bubbling:{listen:true,trigger:true},trickle:1e3,assert:{time:false,hhmmss:false,limit:0}};if(!globalThis.Dumper){globalThis.Dumper=Dumper}else if(globalThis.Dumper!==Dumper){Dumper=globalThis.Dumper}export{Dumper,LogLevel};