const out=console;class LogLevel{#options;constructor({name,value}){this.#options=arguments[0];Object.defineProperties(this,{name:{enumerable:true,value:this.#options.name,},value:{enumerable:true,value:this.#options.value,},});}
static from(level){if(level instanceof LogLevel&&Dumper[level.name])return Dumper[level.name];else if(typeof level==`string`&&Dumper[level.toUpperCase()])return Dumper[level.toUpperCase()];else if(Dumper[level])return Dumper[level];else if(Dumper[level?.value])return Dumper[level?.value];else if(Dumper[level?.name?.toUpperCase()])return Dumper[level?.name?.toUpperCase()];return defaults.level;}
allows(level){if([defaults.level,level].includes(Dumper.OFF))return false;if(level==undefined)return true;return this.value-level.value<=0;}}
const isStatic=(obj)=>obj===Dumper;const copyObject=(original)=>{return JSON.parse(JSON.stringify(original));}
const mergeOptions=(target,...source)=>{var key,i;for(i=0;i<source.length;i++)
for(key in source[i])
if(!(key in target)&&source[i].hasOwnProperty(key))target[key]=source[i][key];else
try{if(target[key].constructor===Object&&source[i][key].constructor===Object)mergeOptions(target[key],source[i][key]);}catch(error){if(error.message.includes('target[key].constructor'))target[key]=source[i][key];}};const pick=(obj,properties)=>{if(!properties)return;if(!Array.isArray(properties)&&(typeof properties=="string"))properties=[properties];const picked={};properties.forEach(prop=>{if(obj.hasOwnProperty(prop))picked[prop]=obj[prop];});return picked;}
const throttle=(func,limitDelay=1000,options={})=>{mergeOptions(options,{skipfirst:false});let inThrottle=options.skipfirst;let inDebounce;return function(){const args=arguments;const context=this;if(!inThrottle){inThrottle=true;func.apply(context,args);inThrottle=setTimeout(()=>inThrottle=undefined,limitDelay);}else{clearTimeout(inDebounce);inDebounce=setTimeout(()=>func.apply(context,args),limitDelay);}}};const formatMessage=(messages,context,style=false)=>{if(typeof context!==`undefined`&&Array.isArray(context.name)&&context.name.length>0){const name='['.concat(context.name.join(' - ')).concat(']');if(style)messages.unshift(Object.entries(style).join('; ').replaceAll(',',': ').concat(';'));messages.unshift((style?'%c':'').concat(name));}};const funcs=['log','trace','debug','info','warn','error','time','timeEnd','timeLog','timeStamp','count','countReset','getLevel','setLevel','children'];const Children=new Map();const Counters={default:0};class Dumper{#options;#children;#context={name:[]};#counters={default:0};static get VERSION(){return'2.4.1';}
get VERSION(){return this.constructor.VERSION;}
constructor({clear=false,level=Dumper.WARN,bubbling={listen:true,trigger:true,},trickle=1000,assert={time:false,hhmmss:false,limit:0,},}=defaults){this.#options=this.#parseOptions((arguments[0]||defaults));for(const func of funcs)this[func]=Dumper[func].bind(this);this.group=out.group.bind(this);this.groupCollapsed=out.groupCollapsed.bind(this);this.groupEnd=out.groupEnd.bind(this);this.clear=out.clear.bind(this);this.trickle=throttle(this.debug,this.#options.trickle);if(!this.dump)this.dump=()=>{};Object.defineProperty(this,Dumper.TRACE.name,{value:Dumper.TRACE,});Object.defineProperty(this,Dumper.DEBUG.name,{value:Dumper.DEBUG,});Object.defineProperty(this,Dumper.INFO.name,{value:Dumper.INFO,});Object.defineProperty(this,Dumper.TIME.name,{value:Dumper.TIME,});Object.defineProperty(this,Dumper.WARN.name,{value:Dumper.WARN,});Object.defineProperty(this,Dumper.ERROR.name,{value:Dumper.ERROR,});Object.defineProperty(this,Dumper.OFF.name,{value:Dumper.OFF,});if(this.#options.clear)this.clear();}#parseOptions(options){let tmp;tmp=pick(options,Object.keys(defaults));mergeOptions(tmp,defaults);tmp.id=Date.now();if(options.linked===true){this.get=Dumper.get.bind(this);this.#children=new Map();this.#context=options.context;}else this.get=Dumper.get.bind(Dumper);return tmp;}
static get(name,{clear=false,level=Dumper.WARN,bubbling={listen:true,trigger:true,},trickle=1000,assert={time:false,hhmmss:false,limit:0,},}=defaults){let options=arguments[1]??{};const children=(this==Dumper||this.#children==undefined)?Children:this.#children;if(!children.has(name)){if(this!=Dumper)mergeOptions(options,this.#options);if(options.level&&options.level.name)options.level=options.level.name;options=copyObject(options);options.level=LogLevel.from(options.level);let context=this==Dumper?{name:[]}:copyObject(this.#context);context.parent=this;context.name.push(name);options.linked=true;options.context=context;const child=new Dumper(options);child.name=name;children.set(name,child);}
return children.get(name);}
static children(){const kids={};for(let child of(this!=Dumper&&this.#children||Children).values())kids[child.name]=child;return kids;}
static get 1(){return this.TRACE;}
static get 2(){return this.DEBUG;}
static get 3(){return this.INFO;}
static get 4(){return this.TIME;}
static get 5(){return this.WARN;}
static get 8(){return this.ERROR;}
static get 99(){return this.OFF;}
static getLevel(){return(isStatic(this)?defaults:this.#options).level;}
static setLevel(level,bubbled=false){let options=(this==Dumper||this.#options==undefined)?defaults:this.#options;if(!(level instanceof LogLevel))level=LogLevel.from(level);if(!bubbled||(this==Dumper||options.bubbling.listen))options.level=level;if((this==Dumper&&level==this.OFF)||(bubbled&&options.bubbling.trigger==false))return;if(this!=Dumper&&this.#children==undefined)return this;if(options.bubbling.trigger)for(let child of(this!=Dumper&&this.#children||Children).values())child.setLevel(level,true);return this;}
static get level(){return this.getLevel();}
static set level(level){return this.setLevel(level);}
get level(){return this.getLevel();}
set level(level){return this.setLevel(level);}
static dump(...msgs){if(out.dump)return out.dump.apply(this,msgs);}
static trace(...messages){formatMessage(messages,(this==Dumper?undefined:this.#context),{color:'DarkBlue'});if(this.getLevel().allows(Dumper.TRACE))return out.trace.apply(this,messages);}
static debug(...messages){formatMessage(messages,(this==Dumper?undefined:this.#context),{color:'LightBlue'});if(this.getLevel().allows(Dumper.DEBUG))return out.debug.apply(this,messages);}
static info(...messages){formatMessage(messages,(this==Dumper?undefined:this.#context),{color:'Blue'});if(this.getLevel().allows(Dumper.INFO))return out.info.apply(this,messages);}
static warn(...messages){formatMessage(messages,(this==Dumper?undefined:this.#context),{color:'Orange'});if(this.getLevel().allows(Dumper.WARN))return out.warn.apply(this,messages);}
static error(...messages){formatMessage(messages,(this==Dumper?undefined:this.#context),{color:'DarkRed'});if(this.getLevel().allows(Dumper.ERROR))return out.error.apply(this,messages);}
static log(...messages){formatMessage(messages,(this==Dumper?undefined:this.#context),{color:'Black'});if(this.getLevel().allows())return out.log.apply(this,messages);}
assert(assertion,...messages){formatMessage(messages,(this==Dumper?undefined:this.#context),{color:'Crimson'});const new_ts=Date.now();const old_ts=this._last_assert||0;if(this.#options.assert.limit&&old_ts&&new_ts-old_ts<this.#options.assert.limit)return false;if(this.#options.assert.time){messages.push(new_ts);const gap_ts=new_ts-old_ts;if(this.#options.assert.hhmmss)messages.push((new Date(gap_ts).toISOString().substr(11,8)).replace(new RegExp('^(00:)+','gm'),''));else messages.push(gap_ts);}
this._last_assert=new_ts;messages.unshift(assertion);if(this.getLevel().allows()){out.assert.apply(this,messages);return!assertion;}
return false;}
static time(label='default'){let messages=[label];formatMessage(messages,(this==Dumper?undefined:this.#context));if(this.getLevel().allows(Dumper.TIME))return out.time.call(this,messages.join(' - '));}
static timeEnd(label='default'){let messages=[label];formatMessage(messages,(this==Dumper?undefined:this.#context));if(this.getLevel().allows(Dumper.TIME))return out.timeEnd.call(this,messages.join(' - '));}
static timeLog(label='default'){let messages=[label];formatMessage(messages,(this==Dumper?undefined:this.#context));if(this.getLevel().allows(Dumper.TIME))return out.timeLog.call(this,messages.join(' - '));}
static timeStamp(){let messages=[Date.now()];formatMessage(messages,(this==Dumper?undefined:this.#context));if(this.getLevel().allows(Dumper.TIME))out.log.call(this,messages.join(' - '));out.timeStamp.call(this);return this;}
static count(label='default',returnCount=false){const counters=(this==Dumper?Counters:this.#counters);if(!counters.hasOwnProperty(label))counters[label]=0;counters[label]+=1;let messages=[`${label}: `+counters[label]];formatMessage(messages,(this==Dumper?undefined:this.#context));if(this.getLevel().allows(Dumper.TIME))out.log.call(this,messages.join(' - '));return returnCount?counters[label]:this;}
static countReset(label='default'){const counters=(this==Dumper?Counters:this.#counters);if(counters.hasOwnProperty(label))counters[label]=0;return this;}
get optionAssertTime(){return this.#options.assert.time;}
set optionAssertTime(assertTime){this.#options.assert.time=Boolean(assertTime);}
get optionAssertLimit(){return this.#options.assert.limit;}
set optionAssertLimit(assertLimit){assertLimit=assertLimit*1;this.#options.assert.limit=assertLimit.toString()=='NaN'?0:assertLimit;}
get optionBubbleFromParent(){return this.#options.bubbling.listen;}
set optionBubbleFromParent(bubble){this.#options.bubbling.listen=Boolean(bubble);return this;}
get optionBubbleToChildren(){return this.#options.bubbling.trigger;}
set optionBubbleToChildren(bubble){this.#options.bubbling.trigger=Boolean(bubble);return this;}
get optionBubble(){return this.optionBubbleFromParent==this.optionBubbleToChildren&&this.optionBubbleToChildren||null;}
set optionBubble(bubble){this.optionBubbleFromParent=bubble;this.optionBubbleToChildren=bubble;return this;}}
Object.defineProperties(Dumper,{TRACE:{value:new LogLevel({value:1,name:'TRACE'}),enumerable:true,},DEBUG:{value:new LogLevel({value:2,name:'DEBUG'}),enumerable:true,},INFO:{value:new LogLevel({value:3,name:'INFO'}),enumerable:true,},TIME:{value:new LogLevel({value:4,name:'TIME'}),enumerable:true,},WARN:{value:new LogLevel({value:5,name:'WARN'}),enumerable:true,},ERROR:{value:new LogLevel({value:8,name:'ERROR'}),enumerable:true,},OFF:{value:new LogLevel({value:99,name:'OFF'}),enumerable:true,},});const defaults={clear:false,level:Dumper.WARN,bubbling:{listen:true,trigger:true,},trickle:1000,assert:{time:false,hhmmss:false,limit:0,}};let ExportDumper=Dumper;if(typeof window.Dumper=='undefined'){window.Dumper=ExportDumper;ExportDumper.dump('DUMPER:','Module','New');}else if(ExportDumper!==window.Dumper){ExportDumper=window.Dumper;ExportDumper.dump('DUMPER:','Replace');}else{ExportDumper.dump('DUMPER:','Module','Existing','This');}
export{ExportDumper as default,ExportDumper as Dumper};