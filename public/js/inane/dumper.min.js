const version='2.0.0-dev';const out=console;function _classPrivateFieldGet(receiver,privateMap){var descriptor=privateMap.get(receiver);if(!descriptor){return undefined;}if(descriptor.get){return descriptor.get.call(receiver);}return descriptor.value;}
var _name=new WeakMap();var _value=new WeakMap();class LogLevel{constructor(options){_name.set(this,{writable:true,value:options.name});_value.set(this,{writable:true,value:options.value});}
get name(){return _classPrivateFieldGet(this,_name);}
get value(){return _classPrivateFieldGet(this,_value);}
allows(level){if([defaults.level,level].includes(Dumper.OFF))return false;if(level==undefined)return true;return this.value-level.value<=0;}}
const data={name:{TRACE:new LogLevel({value:1,name:'TRACE'}),DEBUG:new LogLevel({value:2,name:'DEBUG'}),INFO:new LogLevel({value:3,name:'INFO'}),TIME:new LogLevel({value:4,name:'TIME'}),WARN:new LogLevel({value:5,name:'WARN'}),ERROR:new LogLevel({value:8,name:'ERROR'}),OFF:new LogLevel({value:99,name:'OFF'}),},value:{get[1](){return this.name.TRACE;},get[2](){return this.name.DEBUG;},get[3](){return this.name.INFO;},get[4](){return this.name.TIME;},get[5](){return this.name.WARN;},get[8](){return this.name.ERROR;},get[99](){return this.name.OFF;},},style:{assert:{color:'Crimson'},log:{color:'Black'},trace:{color:'DarkBlue'},debug:{color:'LightBlue'},info:{color:'Blue'},warn:{color:'Orange'},error:{color:'DarkRed'},}};const defaults={clear:false,level:data.name.WARN,updatechain:true,trickle:1000,assert:{time:false,hhmmss:false,limit:0,},};const copyObject=(original)=>{return JSON.parse(JSON.stringify(original));}
const mergeOptions=(target,...objs)=>{var key,i;for(i=0;i<objs.length;i++)
for(key in objs[i])
if(!(key in target)&&objs[i].hasOwnProperty(key))target[key]=objs[i][key];else
try{if(target[key].constructor===Object&&objs[i][key].constructor===Object)mergeOptions(target[key],objs[i][key]);}catch(error){if(error.message.includes('target[key].constructor'))target[key]=objs[i][key];}};const throttle=(func,limitDelay=1000,options={})=>{mergeOptions(options,{skipfirst:false});let inThrottle=options.skipfirst;let inDebounce;return function(){const args=arguments;const context=this;if(!inThrottle){inThrottle=true;func.apply(context,args);inThrottle=setTimeout(()=>inThrottle=undefined,limitDelay);}else{clearTimeout(inDebounce);inDebounce=setTimeout(()=>func.apply(context,args),limitDelay);}}};const formatMessage=(messages,context,style=false)=>{if(typeof context!=='undefined'&&Array.isArray(context.name)&&context.name.length>0){const name='['.concat(context.name.join(' - ')).concat(']');if(style)messages.unshift(Object.entries(style).join('; ').replaceAll(',',': ').concat(';'));messages.unshift((style?'%c':'').concat(name));}};const validateLogLevel=(level)=>{if(Object.values(data.name).includes(level))return level;else if(typeof level==='string'&&Dumper[level.toUpperCase()])return Dumper[level.toUpperCase()];else if(!isNaN(level)&&data.value[Number.parseInt(level)])return data.value[Number.parseInt(level)];else if(typeof level==='object'&&typeof level.name==='string'&&Dumper[level.name.toUpperCase()])return Dumper[level.name.toUpperCase()];else if(typeof level==='object'&&!isNaN(level.value)&&data.level[Number.parseInt(level.value)])return data.level[Number.parseInt(level.value)];return defaults.level;};const Children=new Map();const _children=new WeakMap(),_context=new WeakMap();class Dumper{constructor(options){options=options||{};mergeOptions(options,defaults);if(options.linked===true)this.get=Dumper.get.bind(this);else this.get=Dumper.get.bind(Dumper);delete options.linked;this.log=Dumper.log.bind(this);this.trace=Dumper.trace.bind(this);this.debug=Dumper.debug.bind(this);this.info=Dumper.info.bind(this);this.warn=Dumper.warn.bind(this);this.error=Dumper.error.bind(this);this.time=Dumper.time.bind(this);this.timeEnd=Dumper.timeEnd.bind(this);this.timeLog=Dumper.timeLog.bind(this);this.count=Dumper.count.bind(this);this.countReset=Dumper.countReset.bind(this);this.getLevel=Dumper.getLevel.bind(this);this.setLevel=Dumper.setLevel.bind(this);this.group=out.group.bind(this);this.groupCollapsed=out.groupCollapsed.bind(this);this.groupEnd=out.groupEnd.bind(this);this.clear=out.clear.bind(this);this.trickle=throttle(this.debug,options.trickle);if(!this.dump)this.dump=()=>{};Object.defineProperty(this,Dumper.TRACE.name,{value:Dumper.TRACE,writable:false});Object.defineProperty(this,Dumper.DEBUG.name,{value:Dumper.DEBUG,writable:false});Object.defineProperty(this,Dumper.INFO.name,{value:Dumper.INFO,writable:false});Object.defineProperty(this,Dumper.TIME.name,{value:Dumper.TIME,writable:false});Object.defineProperty(this,Dumper.WARN.name,{value:Dumper.WARN,writable:false});Object.defineProperty(this,Dumper.ERROR.name,{value:Dumper.ERROR,writable:false});Object.defineProperty(this,Dumper.OFF.name,{value:Dumper.OFF,writable:false});if(options.clear)this.clear();this.options=options;}
static get(name,options={}){const children=_classPrivateFieldGet(this,_children)||Children;if(!children.has(name)){if(this.options)mergeOptions(options,this.options);if(options.level&&options.level.name)options.level=options.level.name;options=copyObject(options);options.level=validateLogLevel(options.level);options.linked=true;const child=new Dumper(options);child.name=name;let context=copyObject(_classPrivateFieldGet(this,_context)||{name:[]});context.parent=this;context.name.push(name);_context.set(child,{writable:true,value:context});_children.set(child,{writable:true,value:new Map()});children.set(name,child);}
return children.get(name);}
static get VERSION(){return version;}
get VERSION(){return version;}
static get TRACE(){return data.name.TRACE;}
static get DEBUG(){return data.name.DEBUG;}
static get INFO(){return data.name.INFO;}
static get TIME(){return data.name.TIME;}
static get WARN(){return data.name.WARN;}
static get ERROR(){return data.name.ERROR;}
static get OFF(){return data.name.OFF;}
static getLevel(){return(this.options||defaults).level;}
static setLevel(level,chained=false){const options=this.options||defaults;if(!(level instanceof LogLevel))level=validateLogLevel(level);if(!chained||options.updatechain)options.level=level;if(!this.options&&level==this.OFF)return;else if(this.options&&!(_classPrivateFieldGet(this,_children)))return this;for(let child of(_classPrivateFieldGet(this,_children)||Children).values())child.setLevel(level,true);return this;}
static dump(...vars){if(out.dump)return out.dump.apply(this,vars);}
static trace(...messages){formatMessage(messages,_classPrivateFieldGet(this,_context),data.style.trace);if(this.getLevel().allows(Dumper.TRACE))return out.trace.apply(this,messages);}
static debug(...messages){formatMessage(messages,_classPrivateFieldGet(this,_context),data.style.debug);if(this.getLevel().allows(Dumper.DEBUG))return out.debug.apply(this,messages);}
static info(...messages){formatMessage(messages,_classPrivateFieldGet(this,_context),data.style.info);if(this.getLevel().allows(Dumper.INFO))return out.info.apply(this,messages);}
static warn(...messages){formatMessage(messages,_classPrivateFieldGet(this,_context),data.style.warn);if(this.getLevel().allows(Dumper.WARN))return out.warn.apply(this,messages);}
static error(...messages){formatMessage(messages,_classPrivateFieldGet(this,_context),data.style.error);if(this.getLevel().allows(Dumper.ERROR))return out.error.apply(this,messages);}
static log(...messages){formatMessage(messages,_classPrivateFieldGet(this,_context),data.style.log);if(this.getLevel().allows())return out.log.apply(this,messages);}
assert(assertion,...messages){formatMessage(messages,_classPrivateFieldGet(this,_context),data.style.assert);const new_ts=Date.now();const old_ts=this._last_assert||0;if(this.options.assert.limit&&old_ts&&new_ts-old_ts<this.options.assert.limit)return;if(this.options.assert.time){messages.push(new_ts);const gap_ts=new_ts-old_ts;if(this.options.assert.hhmmss)messages.push((new Date(gap_ts).toISOString().substr(11,8)).replace(new RegExp('^(00:)+','gm'),''));else messages.push(gap_ts);}
this._last_assert=new_ts;messages.unshift(assertion);if(this.getLevel().allows())return out.assert.apply(this,messages);}
static time(label='default'){let messages=[label];formatMessage(messages,_classPrivateFieldGet(this,_context));if(this.getLevel().allows(Dumper.TIME))return out.time.call(this,messages.join(' - '));}
static timeEnd(label='default'){let messages=[label];formatMessage(messages,_classPrivateFieldGet(this,_context));if(this.getLevel().allows(Dumper.TIME))return out.timeEnd.call(this,messages.join(' - '));}
static timeLog(label='default'){let messages=[label];formatMessage(messages,_classPrivateFieldGet(this,_context));if(this.getLevel().allows(Dumper.TIME))return out.timeLog.call(this,messages.join(' - '));}
static count(label='default'){let messages=[label];formatMessage(messages,_classPrivateFieldGet(this,_context));if(this.getLevel().allows(Dumper.TIME))return out.count.call(this,messages.join(' - '));}
static countReset(label='default'){let messages=[label];formatMessage(messages,_classPrivateFieldGet(this,_context));if(this.getLevel().allows(Dumper.TIME))return out.countReset.call(this,messages.join(' - '));}
get optionAssertTime(){return this.options.assert.time;}
set optionAssertTime(assertTime){assertTime=new Boolean(assertTime);this.options.assert.time=assertTime.valueOf();return this;}
get optionAssertLimit(){return this.options.assert.limit;}
set optionAssertLimit(assertLimit){assertLimit=assertLimit*1;this.options.assert.limit=assertLimit.toString()=='NaN'?0:assertLimit;return this;}
get optionUpdatechain(){return this.options.updatechain;}
set optionUpdatechain(update){update=new Boolean(update);this.options.updatechain=update.valueOf();return this;}}
let ExportDumper=Dumper;if(typeof window.Dumper=='undefined'){window.Dumper=ExportDumper;ExportDumper.dump('DUMPER:','set');}else if(ExportDumper!==window.Dumper){ExportDumper=window.Dumper;ExportDumper.dump('DUMPER:','current');}else{ExportDumper.dump('DUMPER:','match');}
export default ExportDumper;