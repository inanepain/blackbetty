if(!Object.prototype.watch){Object.defineProperty(Object.prototype,'watch',{enumerable:!1,configurable:!1,writable:!0,value:function(prop,handler){var getter,setter,change={property:prop,value:this[prop],previous:undefined,set update(v){if(this.value==v)return!1;this.previous=this.value;this.value=v;return!0}},getter=function(){return change.value},setter=function(val){if(change.update=val)handler.call(this,change);return val};if(delete this[prop]){Object.defineProperty(this,prop,{get:getter,set:setter,configurable:!0})}}})}
if(!Object.prototype.unwatch){Object.defineProperty(Object.prototype,'unwatch',{enumerable:!1,configurable:!1,writable:!0,value:function(prop){var val=this[prop];delete this[prop];this[prop]=val}})}
if(!Object.prototype.jsonString){Object.defineProperty(Object.prototype,'jsonString',{enumerable:!1,configurable:!1,writable:!0,value:function(){return JSON.stringify(this)}})}
if(!Object.prototype.pick){Object.defineProperty(Object.prototype,'pick',{enumerable:!1,configurable:!1,writable:!0,value:function(propsArray){if(!propsArray)return;if(!Array.isArray(propsArray)&&(typeof propsArray=="string"))propsArray=[propsArray];propsArray=propsArray.unique();const picked={};propsArray.forEach(prop=>{if(this.hasOwnProperty(prop))picked[prop]=this[prop]});return picked}})}
if(!Object.prototype.readPath){Object.defineProperty(Object.prototype,'readPath',{enumerable:!1,configurable:!1,writable:!0,value:function(path,delimiter='.'){if(!path)return this;const eP=typeof path=='string'?path.split(delimiter):path;let t=Object.assign({},this);for(let i=0;i<eP.length;i++)
if(t&&t.hasOwnProperty(eP[i]))t=t[eP[i]];else t=undefined;return t}})}
if(!Object.prototype.sorted){Object.defineProperty(Object.prototype,'sorted',{enumerable:!1,configurable:!1,writable:!0,value:function(){return this.pick(this.keys().sort())}})}
if(!Object.prototype.propertyRename){Object.defineProperty(Object.prototype,'propertyRename',{enumerable:!1,configurable:!1,writable:!0,value:function(old_key,new_key,force=!1){if(!old_key||!new_key){console.error('Object.propertyRename: old_key and new_key are required.');return this}
if(typeof old_key!=='string'||typeof new_key!=='string'){console.error('Object.propertyRename: old_key and new_key must be strings.');return this}
if(old_key===new_key){console.warn('Object.propertyRename: old_key and new_key are the same, no action taken.');return this}
if(!this.hasOwnProperty(old_key)){console.warn(`Object.propertyRename: old_key "${old_key}" does not exist on this object.`);return this}
if(this.hasOwnProperty(new_key)&&!force){console.warn(`Object.propertyRename: new_key "${new_key}" already exists on this object, no action taken.`);return this}
if(this.hasOwnProperty(new_key)&&force){delete this[new_key]}
Object.defineProperty(this,new_key,Object.getOwnPropertyDescriptor(this,old_key));delete this[old_key];return this}})}
if(!Object.prototype.renameProperty){Object.defineProperty(Object.prototype,'renameProperty',{enumerable:!1,configurable:!1,writable:!0,value:function(old_key,new_key,force=!1){return this.propertyRename(old_key,new_key,force)}})}
if(!Object.prototype.groupByProperty){Object.defineProperty(Object.prototype,'groupByProperty',{enumerable:!1,configurable:!1,writable:!0,value:function(key){try{let target=Array.isArray(this)?this:this.values();return target.reduce((rv,x)=>{(rv[x[key]]=rv[x[key]]||[]).push(x);return rv},{})}catch(error){console.error('Unable to group object.')}}})}
if(!Object.prototype.keys){Object.defineProperty(Object.prototype,'keys',{enumerable:!1,configurable:!1,writable:!0,value:function(){return Object.keys(this)}})}
if(!Object.prototype.values){Object.defineProperty(Object.prototype,'values',{enumerable:!1,configurable:!1,writable:!0,value:function(){return Object.values(this)}})}