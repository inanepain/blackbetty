import Dumper from'/js/inane/dumper.js';class RouteMatch{#route;#options;#url;#errors;constructor({route='',options={},url='',errors=[]}){this.#route=route;this.#options=options;this.#url=url;this.#errors=errors;}
get route(){return this.#route;}
get options(){return this.#options.jsonString().parseJSON();}
get url(){return this.#url;}
get errors(){return this.#errors.jsonString().parseJSON();;}
isValid(){return(this.#errors.length==0);}}
class Router{#routes;#re=/(\[.:[a-z]+\])/i;#logger;constructor({logger,routes,debug=false}={debug:false}){this.#logger=logger||Dumper.get(`Router`,{level:Boolean(debug)?`debug`:`warn`,});this.#routes=routes;this.#logger.debug(`Router (${this.VERSION}):`,`initialised`);}
static get VERSION(){return'0.5.0';}
get VERSION(){return this.constructor.VERSION;}
parseRoute(route,options={}){const routeParams={route:route,options:options,errors:[],};const parts=[];let haystack=this.#routes;for(const part of route.split(`/`)){if(haystack==undefined)continue;let step=haystack[part];if(step==undefined){this.#logger.warn(`Invalid Route:`,route,`Path:`,part);routeParams.errors.push({id:routeParams.errors.length+1,type:`invalid route`,segmant:part,});}else if(step.type.endsWith(`Literal`))
parts.push(step.options.route);else if(step.type.endsWith(`Segment`)){let seg=step.options.route;Object.keys(options).forEach((key)=>{if(seg.includes(`:`.concat(key))){seg=seg.replace(`:`.concat(key),options[key]);delete options[key];}});seg=seg.replace(this.#re,``).replaceAll(`[`,``).replaceAll(`]`,``);parts.push(seg);}
haystack=step?.child_routes;}
routeParams.url=parts.join(``);return new RouteMatch(routeParams);}
resolveRoute(route,options={}){return new Promise((resolve,reject)=>{const routeMatch=this.parseRoute(route,options);if(routeMatch.isValid())resolve(routeMatch);else reject(routeMatch);});}}
export default Router;